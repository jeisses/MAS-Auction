extensions [table]

breed [buyers buyer]

; --- Buyer variables ---
;
; 1) beliefs
; 2) desire
; 3) intention
; 4) private-value: the agen't private value for a good (currently there is only 1 good)
; 5) outgoing-messages
; 6) incomming-messages
buyers-own [beliefs desire intention private-value outgoing-messages incoming-messages wishlist valuations auctrs aucs_wi]

to setup-buyers
	 let xcoords [ -8 -6 -4 -2 0 2 4 6 8 ]
	 create-buyers num-buyers [
	 	let xc first xcoords
    setxy xc min-pycor + 3
		set xcoords remove-item 0 xcoords
    set heading 90
    set color red
    set shape "person"
    
    ; Initial money is random
    let money 100 + (random 40)
    
    ; Draw the buyer's private-values from a normal distribution 
    set private-value (round (random-normal 50 5))
    set label private-value

		set wishlist table:make
		table:put wishlist "wood" random 3 + 5
		table:put wishlist "steel" random 3 + 5
		table:put wishlist "food" random 3 + 5
		table:put wishlist "stone" random 3 + 5

		set valuations table:make
		table:put valuations "wood" random 3 + 5
		table:put valuations "steel" random 3 + 5
		table:put valuations "food" random 3 + 5
		table:put valuations "stone" random 3 + 5

		set beliefs table:make
    
    ; Store the initial belifs
    table:put beliefs "money" money
    table:put beliefs "valuations" valuations
		table:put beliefs "wishlist" wishlist
		table:put beliefs "bought good" false
		table:put beliefs "wishes" (list)
		
    set desire "minimize-price"
    set intention [""]
    set incoming-messages (list)
    set outgoing-messages (list)

		let aucs (list)
		set aucs_wi table:make
		ask auctioneers [ set aucs fput who aucs ]
		print aucs
		let i 0
		
		repeat length aucs [
			table:put aucs_wi item i aucs i
			set i i + 1
		]
		print aucs_wi
		set auctrs (list)
		repeat length aucs [ set auctrs fput table:make auctrs ]
		foreach table:keys aucs_wi [ table:put (item table:get aucs_wi ? auctrs) "id" ? ]
		]
end

to update-buyer-beliefs
  ask buyers [
    ;; Set outgoing-messages to an empty list
    set outgoing-messages (list)
    
		table:put beliefs "wishes" sort-wishes
		
    foreach incoming-messages [
      ;; Message with base prices of all goods. Format is:
      ;; ["price list" auctioneer_id [p1 p2 p3 ...]]
      ifelse first ? = "price" [
        table:put item ( table:get aucs_wi item 1 ? ) auctrs "price" item 2 ?
      ][
      ;; Message about what good is being sold. Format is: 
      ;; ["auction" auctioneer_id good-turtle-id current-bid]
      ifelse first ? = "auction" [
        ;; print ?
        table:put item ( table:get aucs_wi item 1 ? ) auctrs "auctioned good" item 2 ?
        table:put item ( table:get aucs_wi item 1 ? ) auctrs "bid" item 3 ?
      ][
      ;; Message containing the current highest bid. Format is:
      ;; ["current bid" auctioneer_id buyer-id price]
      ifelse first ? = "current bid" [
        table:put item ( table:get aucs_wi item 1 ? ) auctrs "current buyer" item 2 ?
        table:put item ( table:get aucs_wi item 1 ? ) auctrs "bid" item 3 ?
      ][
			;; Message announcing sale
			;; ["deal" buyer_id price good_id auctioneer_id]
			ifelse first ? = "deal" and item 1 ? = who [
        table:put beliefs "money" table:get beliefs "money" - item 2 ? 
				let gtype ""
				ask good item 3 ? [ set gtype good-type ] 
				table:put wishlist gtype (table:get wishlist gtype - 1)
				table:put beliefs "bought good" (list item 3 ? item 4 ? item 2 ?)
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "auctioned good"
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "current buyer"
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "current bid"
			][
      ;; Auction for the current good is closed 
      ifelse first ? = "close auction" or first ? = "deal" [
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "auctioned good"
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "current bid"
        table:remove item ( table:get aucs_wi item 1 ? ) auctrs  "current buyer"
      ][]]]]]
    ] 
    set incoming-messages []
  ]
  
end


to update-buyer-desires
	ask buyers [
		let done  true
		foreach table:keys wishlist [ if table:get wishlist ? > 0 [ set done false ]]
		if done [ set desire "shutdown" ]
	]
end

to update-buyer-intentions
  ask buyers [
    ;; Determine how much we want to bid on the current auction
			
    let bid false
		let bid_in_auction select-auction

		if is-number? bid_in_auction [
			let auc_table table:get aucs_wi bid_in_auction
			let goodtype table:get item auc_table auctrs "auctioned good"
			let currentbid 0
			if table:has-key? item auc_table auctrs "current bid" [
				set currentbid table:get item auc_table auctrs "current bid"
			]
      set bid (basic-bid-strategie (goodtype) (currentbid))
    ]
    

		ifelse is-list? table:get beliefs "bought good"[
			set intention  fput "store good" table:get beliefs "bought good"
			table:put beliefs "bought good" false
		][
    ;; Bidding intentions contains the bid price
    ifelse is-number? bid [
      set intention (list "bid" bid_in_auction bid)
    ][
    ;; Intention to pass the current round
    ifelse bid = false and (table:has-key? beliefs "auctioned good") or (table:get beliefs "money") <= 0 [
      set intention ["pass"]
    ][
    set intention [""]
    ]]]
  ]
end

to execute-buyer-actions
  ask buyers with [not empty? intention] [
    ;; Bidding action
    ifelse first intention = "bid" [
      ;; TODO: support multiple auctioneers
      ;;print (list "Bidding: " (item 1 intention))
      let buyer-id who
      set outgoing-messages fput (list "bid" (item 1 intention) buyer-id (item 2 intention))  outgoing-messages
    ][
    ;; Pass
    ifelse first intention = "pass" [
      set outgoing-messages fput (list "pass") outgoing-messages
    ][
		ifelse first intention = "store good" [
			let xc xcor
			let yc ycor
			
			ask good item 1 intention [ setxy xc yc - 2 ]
			;; message to selling auctioneer ["deal" auctioneer_id good_id price ]
			set outgoing-messages fput (list "deal" item 2 intention item 1 intention item 3 intention) outgoing-messages
		][]]
    ]
  ]
end

;--- Send messages ---
to send-buyer-messages
  ask buyers [
    let msgs outgoing-messages
    ask auctioneers [
      (foreach msgs [
         set incoming-messages fput ? incoming-messages 
      ])
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;
;; BUYER STRATEGIES
;;;;;;;;;;;;;;;;;;;;;

; --- Basic bidding strategy ---
;
; Place bid if private-value is higher than current-bid. Currently always
; bids when private value is larger than current-bid. Should be extended.
to-report basic-bid-strategie [goodtype current-bid]
  let wishvalue (table:get wishlist goodtype) / 100
  let money table:get beliefs "money"
  if money > current-bid[
    report min (list money (current-bid + wishvalue * money))
  ]
  report false
end

to-report sort-wishes
	let wishes (list) 
	foreach table:keys wishlist [ if table:get wishlist ? > 0 [ set wishes fput (list ? table:get valuations ?) wishes ]]
	set wishes sort-by [ item 1 ?1 > item 1 ?2 ] wishes
	report wishes
end

to-report select-auction
	foreach table:get beliefs "wishes" [
		let wish item 0 ?
		foreach auctrs [ if table:has-key? ? "auctioned good" [ if table:get ? "auctioned good" = wish [ report table:get ? "id" ]]]
	]
	report false
end